@precedence {
}

@skip { whitespace | Comment | SpecialTokenSequence }

@top SourceFile { Module? (endOfLine | statement)+ }

Module { ModuleDeclaration DeclDef* | DeclDef+ }

DeclDef {
  AttributeSpecifier
| Declaration
| Constructor
| Destructor
| Postblit  { kwd<"this"> '(' kwd<"this"> ')' MemberFunctionAttribute* (';' | FunctionBody) }
| Invariant { kwd<"invariant"> (BlockStatement | '(' (assertArguments ')' ';' | ')' BlockStatement)) }
| UnitTest
| AliasThis
| StaticConstructor
| StaticDestructor
| SharedStaticConstructor
| SharedStaticDestructor
| ConditionalDeclaration
| DebugSpecification
| VersionSpecification
| StaticAssert
| TemplateDeclaration
| TemplateMixinDeclaration
| TemplateMixin
| MixinDeclaration
| EmptyDeclaration
}

EmptyDeclaration { ';' }

ModuleDeclaration { ModuleAttribute* kwd<"module"> ModuleFullyQualifiedName ';' }
ModuleAttribute { DeprecatedAttribute | UserDefinedAttribute }
ModuleFullyQualifiedName { Identifier ( '.' Identifier )* }

ImportDeclaration { kwd<"public">? kwd<"static">? kwd<"import"> ImportList ';' }
ImportList { importBindings | import (',' ImportList)? }
import {( Identifier '=')? ModuleFullyQualifiedName }
importBindings { import ':' importBind (',' importBind )*}
importBind { Identifier ('=' Identifier )? }

MixinDeclaration { MixinExpression ';' }

Declaration {
  FuncDeclaration
| VarDeclarations ';'
| AliasDeclaration ';'
| AliasAssign { Identifier '=' Type }
| AggregateDeclaration
| EnumDeclaration
| ImportDeclaration
| ConditionalDeclaration
| StaticForeachDeclaration
| StaticAssert
}

AggregateDeclaration {
  ClassDeclaration
| InterfaceDeclaration
| StructDeclaration
| UnionDeclaration
}

VarDeclarations { StorageClass* BasicType Declarators | AutoDeclaration }

Declarators { DeclaratorInitializer (',' DeclaratorIdentifier)* }
DeclaratorInitializer { Declarator (templateParameters? '=' Initializer)? }
DeclaratorIdentifier  { Identifier (templateParameters? '=' Initializer)? }
Declarator { typeSuffix* Identifier }

StorageClass {
  LinkageAttribute | AlignAttribute | AtAttribute | TypeCtor
| kwd<"deprecated"> | kwd<"enum"> | kwd<"static"> | kwd<"abstract"> | kwd<"final"> | kwd<"override">
| kwd<"synchronized"> | kwd<"auto"> | kwd<"scope">| kwd<"__gshared"> | FunctionAttributeKwd | kwd<"ref">
}

Initializer { kwd<"void"> | nonVoidInitializer }
nonVoidInitializer { AssignExpression | ArrayLiteral | StructInitializer }

AutoDeclaration { StorageClass+ autoAssignment (',' autoAssignment)* }
autoAssignment  { Identifier templateParameters? '=' Initializer }

AliasDeclaration {
  kwd<"alias"> (
    StorageClass* BasicType (Declarators | FuncDeclarator)
  | aliasAssignment (',' aliasAssignment)*
  )
}
aliasAssignment {
  Identifier templateParameters? '=' (
    StorageClass* (Type | BasicType Parameters MemberFunctionAttribute*)
  | FunctionLiteral
  )
}

AliasReassignment {
  Identifier '=' (
    StorageClass* (Type | BasicType Parameters MemberFunctionAttribute*)
  | FunctionLiteral
  )
}

Type { TypeCtor* BasicType typeSuffix* }

TypeCtor { kwd<"const"> | kwd<"immutable"> | kwd<"inout"> | kwd<"shared"> }

BasicType {
  FundamentalType
| '.'? QualifiedIdentifier
| Typeof ('.' QualifiedIdentifier)?
| TypeCtor '(' Type ')'
| vector { kwd<"__vector"> '(' Type ')' }
| TraitsExpression
| MixinType { MixinExpression }
}

FundamentalType {
  kwd<"bool"> | kwd<"byte"> | kwd<"ubyte"> | kwd<"short"> | kwd<"ushort"> | kwd<"int"> | kwd<"uint">
| kwd<"long"> | kwd<"ulong"> | kwd<"cent"> | kwd<"ucent"> | kwd<"char"> | kwd<"wchar"> | kwd<"dchar">
| kwd<"float"> | kwd<"double"> | kwd<"real"> | kwd<"ifloat"> | kwd<"idouble"> | kwd<"ireal">
| kwd<"cfloat"> | kwd<"cdouble"> | kwd<"creal"> | kwd<"void">
}

typeSuffix {
  '*'
| '[' (AssignExpression (".." AssignExpression)? | Type)? ']'
| kwd<"delegate"> Parameters MemberFunctionAttribute*
| kwd<"function"> Parameters FunctionAttribute*
}

QualifiedIdentifier { Identifier ('[' AssignExpression ']' | templateArguments)? ('.' QualifiedIdentifier)? }

Typeof { kwd<"typeof"> '(' (Expression | kwd<"return">) ')' }

AttributeSpecifier { Attribute (':' | DeclarationBlock)? }
Attribute {
  LinkageAttribute | AlignAttribute | DeprecatedAttribute | VisibilityAttribute
| AtAttribute | TypeCtor | FunctionAttributeKwd | Pragma
| kwd<"static"> | kwd<"abstract"> | kwd<"final"> | kwd<"override"> | kwd<"synchronized">
| kwd<"auto"> | kwd<"scope"> | kwd<"__gshared"> | kwd<"ref"> | kwd<"return">
}
FunctionAttributeKwd { kwd<"nothrow"> | kwd<"pure"> }
AtAttribute {
    '@' ("disable" | "nogc" | "live" | "property" | "safe" | "system" | "trusted")
    | UserDefinedAttribute
}

DeclarationBlock { DeclDef | '{' DeclDef* '}' }

LinkageAttribute {
  kwd<"extern"> ('('(
    LinkageType
  | 'C' "++" ',' (QualifiedIdentifier | NamespaceList)?
  )')')?
}
LinkageType { 'C' "++"? | 'D' | "Windows" | "System" | "Objective" '-' 'C' }
NamespaceList { ConditionalExpression (',' NamespaceList?)? }

AlignAttribute { kwd<"align"> ( '(' AssignExpression ')' )? }
DeprecatedAttribute { kwd<"deprecated"> ( '(' AssignExpression ')' )? }

VisibilityAttribute { kwd<"private"> | kwd<"package"> '(' QualifiedIdentifier ')' | kwd<"protected"> | kwd<"public"> | kwd<"export"> }

UserDefinedAttribute { '@' ('(' ArgumentList ')' | Identifier templateArguments? ('(' ArgumentList? ')')?) }

PragmaDeclaration { pragma (';' | DeclarationBlock) }
PragmaStatement   { pragma (';' | noScopeStatement) }
pragma { kwd<"pragma"> '(' Identifier (',' ArgumentList)? ')' }

Expression { CommaExpression }
CommaExpression  { (CommaExpression ',')? AssignExpression }
AssignExpression { ConditionalExpression (assignmentToken AssignExpression)? }
ConditionalExpression { OrOrExpression ('?' Expression ':' ConditionalExpression)? }
OrOrExpression   { (OrOrExpression "||")? AndAndExpression }
AndAndExpression { (AndAndExpression "&&")? OrExpression }
OrExpression     { (OrExpression '|')? XorExpression }
XorExpression    { (XorExpression '^')? AndExpression }
AndExpression    { (AndExpression '&')? CmpExpression }

CmpExpression { EqualExpression | IdentityExpression | RelExpression | InExpression | ShiftExpression }
EqualExpression { ShiftExpression $[=!] '=' ShiftExpression }
IdentityExpression { ShiftExpression '!'? kwd<"is"> ShiftExpression }
RelExpression   { ShiftExpression $[<>] '='? ShiftExpression }
InExpression       { ShiftExpression '!'? kwd<"in"> ShiftExpression }
ShiftExpression { (ShiftExpression ("<<" | ">>" | ">>>"))? AddExpression }

AddExpression { (AddExpression $[+-~])? MulExpression }
MulExpression { (MulExpression $[*/%])? UnaryExpression }

UnaryExpression {
  ThrowExpression
  | PowExpression
  | ($[&*!~] | '+' '+'? | '-' '-'? | kwd<"delete"> | kwd<"cast"> '(' (Type | TypeCtors)? ')') UnaryExpression
}

NewExpression { kwd<"new"> Type ('[' AssignExpression ']' | '(' ArgumentList? ')')? | NewAnonClassExpression }

ThrowExpression { kwd<"throw"> AssignExpression ';' }
PowExpression { PostfixExpression ("^^" UnaryExpression)? }

PostfixExpression {
  PrimaryExpression
| PostfixExpression (
    '.' (Identifier templateArguments? | NewExpression)
  | "++" | "--"
  | '(' ArgumentList? ')'
  | '[' (ArgumentList | Slice ','?)? ']'
  |
  )?
| TypeCtor* BasicType '(' ArgumentList? ')'
}
Slice { AssignExpression (".." AssignExpression)? (',' Slice)? }

PrimaryExpression {
  '.'? Identifier templateArguments?
| kwd<"this"> | kwd<"super"> | kwd<"null"> | kwd<"true"> | kwd<"false"> | '$'
| IntegerLiteral | FloatLiteral | CharacterLiteral
| StringLiteral+ | ArrayLiteral | AssocArrayLiteral | FunctionLiteral
| AssertExpression | MixinExpression | ImportExpression | NewExpression
| FundamentalType . Identifier
| '(' Type ')' '.' (Identifier templateArguments?)
| FundamentalType '(' ArgumentList? ')'
| TypeCtor '(' Type ')' '.' (Identifier | '(' ArgumentList? ')')
| Typeof
| TypeidExpression | IsExpression
| '(' Expression ')'
| SpecialKeyword
| TraitsExpression
}

ArrayLiteral { '[' (ArrayMemberInitialization (',' ArrayMemberInitialization)*)? ']' }
ArrayMemberInitialization { (AssignExpression ':')? nonVoidInitializer }

AssocArrayLiteral { '[' KeyValuePair (',' KeyValuePair)* ']' }
KeyValuePair { AssignExpression ':' AssignExpression }

FunctionLiteral {
  kwd<"function"> kwd<"ref">? Type? ParameterWithAttributes? FunctionLiteralBody2
| kwd<"delegate"> kwd<"ref">? Type? ParameterWithMemberAttributes? FunctionLiteralBody2
| kwd<"ref">? ParameterWithMemberAttributes FunctionLiteralBody2
| SpecifiedFunctionBody
| Identifier "=>" AssignExpression
}
ParameterWithAttributes { Parameters FunctionAttribute* }
ParameterWithMemberAttributes { Parameters MemberFunctionAttribute* }
FunctionLiteralBody2 { "=>" AssignExpression | SpecifiedFunctionBody }

AssertExpression { kwd<"assert"> '(' assertArguments ')' }
assertArguments { AssignExpression (',' AssignExpression)? ','? }

MixinExpression  { kwd<"mixin">  '(' ArgumentList ')' }

ImportExpression { kwd<"import"> '(' AssignExpression ')' }

TypeidExpression { kwd<"typeid"> '(' (Type | Expression) ')' }

IsExpression { kwd<"is"> '(' Type (Identifier? ((':' | "==") TypeSpecialization (',' list<templateParameter>)?)?) ')' }

TypeSpecialization {
  Type | TypeCtor
| kwd<"struct"> | kwd<"union">  | kwd<"class"> | kwd<"interface">
| kwd<"enum"> | kwd<"__vector"> | kwd<"function"> | kwd<"delegate">
| kwd<"super"> | kwd<"return">  | kwd<"__parameters">
| kwd<"module"> | kwd<"package">
}

SpecialKeyword { kwd<"__" ("FILE" "_FULL_PATH"? | "MODULE" | "LINE" | "PRETTY_"? "FUNCTION") "__"> }

statement { EmptyStatement | noScopeNonEmptyStatement }
EmptyStatement { ';' }
noScopeNonEmptyStatement { nonEmptyStatement | BlockStatement }
noScopeStatement { statement }
nonEmptyOrScopeBlockStatement { noScopeNonEmptyStatement }

nonEmptyStatement {
  nonEmptyStatementNoCaseNoDefault
| CaseStatement
| CaseRangeStatement
| DefaultStatement
}

nonEmptyStatementNoCaseNoDefault {
  LabeledStatement
| expressionStatement  { Expression ';' }
| declarationStatement { StorageClass* Declaration }
| IfStatement
| WhileStatement
| DoStatement
| ForStatement
| foreachStatement
| SwitchStatement
| finalSwitchStatement
| ContinueStatement { kwd<"continue"> Identifier? ';' }
| BreakStatement { kwd<"break"> Identifier? ';' }
| ReturnStatement { kwd<"return"> Expression? ';' }
| GotoStatement { kwd<"goto"> (Identifier | kwd<"default"> | kwd<"case"> Expression?) ';' }
| WithStatement { kwd<"with"> '(' (Expression | Symbol | Identifier templateArguments) ')' scopeStatement }
| SynchronizedStatement { kwd<"synchronized"> ('(' Expression ')')? scopeStatement }
| TryStatement
| ScopeGuardStatement
| AsmStatement { kwd<"asm"> FunctionAttribute* '{' (asmInstruction ';')* '}' }
| MixinStatement { MixinExpression ';' }
| foreachRangeStatement
| PragmaStatement
| ConditionalStatement
| StaticForeachStatement
| StaticAssert
| TemplateMixin
| ImportDeclaration
}

scopeStatement { nonEmptyStatement | BlockStatement }

LabeledStatement { Identifier ':' Statement? }

BlockStatement { '{' Statement* '}' }

IfStatement { kwd<"if"> '(' ifCondition ')' ThenStatement { scopeStatement } (ElseStatement { scopeStatement })? }
ifCondition {
  ( ( (kwd<"auto"> | kwd<"scope"> | TypeCtor+) Identifier
    | TypeCtor* BasicType Declarator
    ) '='
  )? Expression
}

WhileStatement { kwd<"while"> '(' ifCondition ')' scopeStatement }

DoStatement { kwd<"do"> scopeStatement kwd<"while"> '(' Expression ')' ';' }

ForStatement { kwd<"for"> initialize Expression? ';' Expression? }
initialize { ';' | noScopeNonEmptyStatement }

aggregateForeach { Foreach '(' foreachType (',' foreachType)* ';' Expression ')' }
foreachStatement { aggregateForeach noScopeNonEmptyStatement }

Foreach { kwd<"foreach"> | kwd<"foreach_reverse"> }

foreachType { ForeachTypeAttribute* (BasicType Declarator | kwd<"alias">? Identifier ) }
ForeachTypeAttribute { kwd<"enum"> | kwd<"ref"> | kwd<"scope"> | TypeCtor }

rangeForeach { Foreach '(' ForeachType ';' Expression ".." Expression ')' }
foreachRangeStatement { rangeForeach scopeStatement }

SwitchStatement { kwd<"switch"> '(' Expression ')' scopeStatement }
CaseStatement { kwd<"case"> ArgumentList ':' statementNoCaseNoDefault* }
CaseRangeStatement { kwd<"case"> AssignExpression ':' ".." kwd<"case"> AssignExpression ':' statementNoCaseNoDefault* }
DefaultStatement { kwd<"default"> ':' statementNoCaseNoDefault* }
statementNoCaseNoDefault { EmptyStatement | nonEmptyStatementNoCaseNoDefault | BlockStatement }
finalSwitchStatement { kwd<"final"> SwitchStatement }

TryStatement { kwd<"try"> scopeStatement (catch+ FinallyStatement? | FinallyStatement) }
catch { kwd<"catch"> '(' BasicType Identifier? ')' noScopeNonEmptyStatement }
FinallyStatement { kwd<"finally"> noScopeNonEmptyStatement }

ScopeGuardStatement { kwd<"scope"> '(' (kwd<"exit"> | kwd<"success"> | kwd<"failure">) ')' nonEmptyOrScopeBlockStatement }

StructDeclaration {
  kwd<"struct"> (
      Identifier (';' | AggregateBody | TemplateParameters (';' | Constraint? AggregateBody))
    | AggregateBody
  )
}

UnionDeclaration {
  kwd<"union"> (
      Identifier (';' | AggregateBody | TemplateParameters (';' | Constraint? AggregateBody))
    | AggregateBody
  )
}

AggregateBody { '{' DeclDef* '}' }

StructInitializer { '{' list<StructMemberInitializer>? '}' }
StructMemberInitializer { (Identifier ':')? nonVoidInitializer }

ClassDeclaration {
  kwd<"class"> Identifier (
    ';'
    | BaseClassList? AggregateBody
    | TemplateParameters (';' | (Constraint? BaseClassList? | BaseClassList? Constraint?) AggregateBody)
  )
}

BaseClassList { ':' Interfaces }
Interfaces { BasicType (',' BasicType)* }

Constructor { kwd<"this"> '(' ')' MemberFunctionAttribute* FunctionBody | ConstructorTemplate }
Destructor  { '~' kwd<"this"> '(' ')' MemberFunctionAttribute* FunctionBody }
StaticConstructor { kwd<"static"> kwd<"this"> '(' ')' MemberFunctionAttribute* (';' | FunctionBody) }
StaticDestructor  { kwd<"static"> '~' kwd<"this"> '(' ')' MemberFunctionAttribute* (';' | FunctionBody) }
sharedStaticConstructor { kwd<"shared"> StaticConstructor }
sharedStaticDestructor  { kwd<"shared"> StaticDestructor }

AliasThis { kwd<"alias"> Identifier kwd<"this"> ';' }

NewAnonClassExpression { kwd<"new"> kwd<"class"> ('(' ArgumentList? ')')? BasicType? Interfaces? AggregateBody }

InterfaceDeclaration {
  kwd<"interface"> Identifier (
      ';'
    | BaseClassList? AggregateBody
    | TemplateParameters (';' | (Constraint? BaseClassList? | BaseClassList Constraint) AggregateBody)
  )
}

EnumDeclaration {
  kwd<"enum"> (
      Identifier (':' Type)? (';' | '{' list<EnumMember> '}')
    | ':' Type '{' list<EnumMember> '}'
    | '{' list<AnonymousEnumMember> '}'
  )
}

EnumMember { enumMemberAttribute* Identifier ('=' AssignExpression)? }
enumMemberAttribute { DeprecatedAttribute | UserDefinedAttribute | "@disable" }

AnonymousEnumMember { EnumMember | Type Identifier '=' AssignExpression }

FuncDeclaration { StorageClass* BasicType FuncDeclarator FunctionBody | AutoFuncDeclaration }

AutoFuncDeclaration { StorageClass+ Identifier FuncDeclaratorSuffix FunctionBody }

FuncDeclarator { TypeSuffix* Identifier FuncDeclaratorSuffix }

FuncDeclaratorSuffix {
    Parameters MemberFunctionAttribute*
  | TemplateParameters Parameters MemberFunctionAttribute* Constraint?
}

Parameters { '(' parameterList? ')' }
parameterList { VariadicArgumentsAttribute* "..." | Parameter (',' parameterList?)? }

Parameter { parameterAttribute* (BasicType Declarator | Type) ("..." | '=' AssignExpression)? }
parameterAttribute { InOut | UserDefinedAttribute }

InOut {
    TypeCtor
  | kwd<"auto"> | kwd<"final"> | kwd<"in"> | kwd<"lazy">
  | kwd<"out">  | kwd<"ref"> | kwd<"return"> | kwd<"scope">
}

VariadicArgumentsAttribute { kwd<"const"> | kwd<"immutable"> | kwd<"return"> | kwd<"scope"> | kwd<"shared"> }

FunctionAttribute { FunctionAttributeKwd | AtAttribute }

MemberFunctionAttribute { VariadicArgumentsAttribute | FunctionAttribute | kwd<"inout"> }

FunctionBody { SpecifiedFunctionBody | MissingFunctionBody | ShortenedFunctionBody }

SpecifiedFunctionBody {
    (   kwd<"do">?
      | FunctionContract* (InOutContractExpression kwd<"do">? | InOutStatement kwd<"do">)
    ) BlockStatement
}

MissingFunctionBody { ';' | FunctionContract* (InOutContractExpression ';' | InOutStatement) }

ShortenedFunctionBody { InOutContractExpression* "=>" AssignExpression ';' }

FunctionContract { InOutContractExpression | InOutStatement }

InOutContractExpression { InContractExpression | OutContractExpression }

InOutStatement { InStatement | OutStatement }

InContractExpression  { kwd<"in"> '(' AssertArguments ')' }
OutContractExpression { kwd<"out"> '(' Identifier? ';' AssertArguments ')' }

InStatement  { kwd<"in"> BlockStatement }
OutStatement { kwd<"out"> ('(' Identifier ')')? BlockStatement }

MainFunction { MainReturnDecl "main" '(' ("string" '[' ']' Identifier)? ')' BlockStatement }
MainReturnDecl { kwd<"void"> | kwd<"int"> | "noreturn" | kwd<"auto"> }

TemplateDeclaration { kwd<"template"> Identifier templateParameters Constraint? AggregateBody }

templateParameters { '(' list<templateParameter>? ')' }

templateArguments { '!' (TemplateSingleArgument | '(' list<TemplateArgument>? ')') }

TemplateArgument { Type | AssignExpression | Symbol }

Symbol { '.'? symbolTail }
symbolTail { Identifier templateArguments? ('.' symbolTail)? }

TemplateSingleArgument {
  Identifier | FundamentalType | CharacterLiteral
| StringLiteral | IntegerLiteral | FloatLiteral
| kwd<"true"> | kwd<"false"> | kwd<"null"> | kwd<"this">
| SpecialKeyword
}

templateParameter {
  TemplateTypeParameter     { Identifier (':' Type)? ('=' Type)? }
| TemplateValueParameter
| TemplateAliasParameter
| TemplateSequenceParameter { Identifier "..." }
| TemplateThisParameter     { kwd<"this"> TemplateTypeParameter }
}
TemplateValueParameter {
  BasicType Declarator
  (':' ConditionalExpression)?
  ('=' (AssignExpression | SpecialKeyword))?
}
TemplateAliasParameter {
  kwd<"alias"> (Identifier | BasicType Declarator)
  (':' (Type | ConditionalExpression))?
  ('=' (Type | ConditionalExpression))?
}

ConstructorTemplate { kwd<"this"> TemplateParameters Parameters MemberFunctionAttribute* Constraint? (':' | FunctionBody) }

Constraint { kwd<"if"> '(' Expression ')' }

TemplateMixinDeclaration { kwd<"mixin"> kwd<"template"> Identifier templateParameters Constraint? AggregateBody }

TemplateMixin { kwd<"mixin"> MixinTemplateName templateArguments? Identifier? ';' }

MixinTemplateName { Typeof? '.'? MixinQualifiedIdentifier }

MixinQualifiedIdentifier { Identifier (templateArguments? '.' MixinQualifiedIdentifier)? }

ConditionalDeclaration { condition (DeclarationBlock kwd<"else">)? (DeclarationBlock | ':' DeclDef*) }

ConditionalStatement { condition noScopeNonEmptyStatement (kwd<"else"> noScopeNonEmptyStatement)?}

condition { VersionCondition | DebugCondition | StaticIfCondition }

VersionCondition { kwd<"version"> '(' (IntegerLiteral | Identifier | kwd<"unittest"> | kwd<"assert">) ')' }

VersionSpecification { kwd<"version"> '=' (Identifier | IntegerLiteral) ';' }

DebugCondition { kwd<"debug"> ('(' (IntegerLiteral | Identifier) ')')? }

DebugSpecification { kwd<"debug"> '=' (Identifier | IntegerLiteral) ';' }

StaticIfCondition { kwd<"static"> kwd<"if"> '(' AssignExpression ')' }

staticForeach { kwd<"static"> (aggregateForeach | rangeForeach) }

StaticForeachDeclaration { staticForeach (DeclarationBlock | ':' DeclDef*) }

StaticForeachStatement { staticForeach noScopeNonEmptyStatement }

StaticAssert { kwd<"static"> kwd<"assert"> '(' assertArguments ')' ';' }

TraitsExpression { kwd<"__traits"> '(' TraitsKeyword ',' traitsArgument (',' traitsArgument)* ')' }
traitsArgument { AssignExpression | Type }

TraitsKeyword {
  "is" (
    "AbstractClass" | "Arithmetic" | "AssociativeArray" | "FinalClass" | "POD" | "Nested"
  | "Future" | "Deprecated" | "Floating" | "Integral" | "Scalar" | "StaticArray" | "Unsigned"
  | "Disabled" | "VirtualFunction" | "VirtualMethod" | "AbstractFunction" | "FinalFunction"
  | "StaticFunction" | "OverrideFunction" | "Template" | "Ref" | "Out" | "Lazy"
  | "ReturnOnStack" | "Copyable" | "ZeroInit" | "Module" | "Package" | "Same"
  )
| "has" ( "Member" | "CopyConstructor" | "Postblit" )
| "get" (
    "AliasThis" | "Attributes" | "FunctionAttributes" | "FunctionVariadicStyle"
  | "Linkage" | "Location" | "Member" | "Overloads" | "ParameterStorageClasses"
  | "PointerBitmap" | "CppNamespaces" | "Visibility" | "Protection" | "TargetInfo"
  | "VirtualFunctions" | "VirtualIndex" | "VirtualMethods" | "UnitTests"
  )
| "identifier" | "parent" | "child" | "classInstanceSize" | "allMembers" | "derivedMembers"
| "compiles" | "toType" | "initSymbol" | "parameters"
}

kwd<word>  { @specialize[@name={word}]<Identifier, word> }

list<term> { term (',' list<term>?)? }


@tokens {
  character { $[\u{20}-\u{10FFFF}] }

  endOfFile { $[\u0000\u001A] }
  
  endOfLine { "\r" | "\n" | "/r/n" | "\u2028" | "\u2029" | endOfFile? }
  
  whiteSpace { space+ }
  space { $[ \t\v\f] }
  
  Comment { BlockComment | LineComment | NestingBlockComment }
  
  BlockComment { "/*" ![*/]* "*/" }
  LineComment { "//" (!endOfLine)* }
  NestingBlockComment { "/+" nestingBlockCommentCharacter* "+/" }
  nestingBlockCommentCharacter { !"+/" | NestingBlockComment }
  
  @precedence { LineComment, NestingBlockComment, BlockComment }
  
  Identifier {
    ($[a-zA-Z_] | universalAlpha) ($[a-zA-Z0-9_] | universalAlpha)*
  }
  universalAlpha {
      latin { $[ªºµ·À-ÖØ-öø-ʯʰ-ʸʻ-ˁːˑˠ-ˤḀ-ỿⁿ] }
    | greek { $[ͺΆΈ-ΊΌΎ-ΡΣ-ϳἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ] }
    | cyrillic { $[Ѐ-ҁҊ-ӿ] }
    | armenian { $[Ա-Ֆՙա-և] }
    | hebrew { $[\u05BB−\u05C2\u05D0−\u05EA\u05F0−\u05F2] }
    | arabic { $[\u0620-\u0652\u0660-\u0669\u0670-\u06DC\u06E5-\u06E8\u06EA-\u06F9] }
    | devanagari { $[\u0900-\u0939ऽ-\u0963०-९] }
    | bengali { $[ঀ-\u0983অ-ঌএঐও-নপরলশ-হ\u09BE-\u09C4\u09C7\u09C8\u09CB-ৎড়ঢ়য়-\u09E3০-৯] }
    | gurmukhi { $[\u0A02ਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4Dਖ਼-ੜਫ਼੦-੯ੴ] }
    | gujarati { $[\u0A81-\u0A83અ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACDૐૠૡ૦-૯ૹ] }
    | oriya { $[\u0B01-ଃଅ-ଌଏଐଓ-ନପ-ରଲହଽ\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4Dଡ଼ଢ଼ୟ-ୡ୦-୯ୱ] }
    | tamil { $[\u0B82\u0B83அ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-\u0BC2ெ-ை\u0BCA-\u0BCD௦-௯] }
    | telugu { $[ఁ-ఌఎ-ఐఒ-నప-హఽ-\u0C44\u0C46-\u0C48\u0C4A-\u0C4Dౠౡ౦-౯] }
    | kannada { $[ಀ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCDೞೠೡ೦-೯] }
    | malayalam { $[\u0D02-ഌഎ-ഐഒ-ഺഽ-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D൘-ൡ൦-ൿ] }
    | thai { $[ก-\u0E3Aเ-๛] }
    | lao { $[ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອຮ\u0EB0-\u0EB9\u0EBB-ຽເ-ໄໆ\u0EC8-\u0ECD໐-໙ໜ-ໟ] }
    | tibetan { $[ༀ\u0F18\u0F19༠-༳\u0F35\u0F37\u0F39\u0F3E-ཇཉ-ཬ\u0F71-ྌ\u0F90-\u0F97\u0F99-\u0FBC] }
    | georgian { $[Ⴀ-ჅჇჍა-ჺჼ-ჿ] }
    | hiragana { $[ぁ-ゖ゛゜ゟ] }
    | katakana { $[ァ-ーヿ] }
    | bopomofo { $[ㄅ-ㄭ] }
    | cjk { $[々-〇〡-〩\u4E00—\u9FFF] }
    | hangul { $[\uAC00—\uD7AF] }
    | other { $[‿⁀ℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℱℳ-ℸⅠ-ↂ] }
  }
  
  StringLiteral {
    ( WysiwygString
    | AlternateWysiwygString
    | DoubleQuotedString
    | DelimitedString
    | TokenString
    ) StringPostfix?
  }
  
  WysiwygString { `r"` !["]* `"` }
  wysiwygCharacter { character | '\n' }
  AlternateWysiwygString { '`' ![`]* '`' }
  DoubleQuotedString { `"` (EscapeSequence | !["])* `"` }
  EscapeSequence {
    '\' 
    ( $['"?\0abfnrtv]
    | 'x' HexDigit HexDigit
    | OctalDigit OctalDigit? OctalDigit?
    | 'u' HexDigit HexDigit HexDigit HexDigit
    | 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
    | NamedCharacterEntity )
  }
  StringPostfix { $[cwd] }
  DelimitedString { `q"` delimitedStringContent `"` }
  delimitedStringContent {
      delimiterLeft !["]* delimiterRight
    | parenDelimitedString
    | brackDelimitedString
    | braceDelimitedString
    | angleDelimitedString
  }
  delimiterLeft  { Identifier '\n' | $[!#-'*-/:-@\\^`|~¡-¿×÷] }
  delimiterRight { '\n' Identifier | $[!#-'*-/:-@\\^`|~¡-¿×÷] }
  TO-DO: Is there a way to correctly parse the above without an external tokenizer?
  parenDelimitedString { '(' ![()]* parenDelimitedString? ![()]* ')' }
  brackDelimitedString { '[' ![[]]* brackDelimitedString? ![[]]* ']' }
  braceDelimitedString { '{' ![{}]* braceDelimitedString? ![{}]* '}' }
  angleDelimitedString { '<' ![<>]* angleDelimitedString? ![<>]* '>' }
  
  TokenString { 'q{' tokenNoBraces* tokenStringContent* tokenNoBraces* '}' }
  tokenStringContent { tokenNoBraces | '{' tokenStringContent? '}' }
  tokenNoBraces {
    Identifier | StringLiteral | CharacterLiteral | IntegerLiteral | FloatLiteral | Keyword
    | '&' $[=&]? | '|' $[=&]? | '-' $[=-]? | '+' $[=+]? | '.' '.'? '.'? | $[()\[\]?,;:$@#]
    | (( $[/<>!=*%^~] | '^^' | '<<' | '>>' | '>>>' ) '='? ) | '=>'
  }
  assignmentToken { ($[+-*/%&|^~] | "<<" | ">>" | ">>>" | "^^")? '=' }
  comparisonToken { $[<>!=] '=' }
  '{' '}'
  
  CharacterLiteral { "'" (character | EscapeSequence)? "'" }
  
  IntegerLiteral { integer integerSuffix? }
  integerSuffix { 'L' $[uU]? | $[uU] 'L'? }
  
  integer { decimalInteger | binaryInteger | hexadecimalInteger | octalInteger }
  
  decimalInteger { '0' | $[1-9] $[0-9_]* }
  binaryInteger  { '0' $[bB] "_"* $[01] $[01_]* }
  hexadecimalInteger { '0' $[xX] '_'* HexDigit (HexDigit | '_')* }
  octalInteger { '0' $[0_]* OctalDigit '_'* }
  
  decimalDigitsNoSingleUS { decimalDigitsNoStartingUS | '_' $[0-9_]* }
  decimalDigitsNoStartingUS { $[0-9] $[0-9_]* }
  OctalDigit { $[0-7] }
  hexDigitsNoSingleUS { hexDigitsNoStartingUS | '_' (HexDigit | '_')* }
  hexDigitsNoStartingUS { HexDigit (HexDigit | '_')* }
  HexDigit   { $[0-9a-fA-F] }
  
  FloatLiteral {
      float $[fFL]? 'i'?
    | integer ( $[fF] 'i'? | 'L'? 'i' )
  }
  
  float { decimalFloat | hexFloat }
  
  decimalFloat {
      decimalDigitsNoStartingUS '.' decimalDigitsNoStartingUS?
    | decimalDigitsNoStartingUS? '.' decimalDigitsNoStartingUS decimalExponent
    | decimalDigitsNoStartingUS decimalExponent
  }
  decimalExponent { $[eE] $[+-]? decimalDigitsNoSingleUS }
  hexFloat {
    '0' $[xX] (
        hexDigitsNoSingleUS? '.' hexDigitsNoStartingUS hexExponent
      | hexDigitsNoSingleUS hexExponent
    )
  }
  hexExponent { $[pP] $[+-]? decimalDigitsNoSingleUS }
  
  SpecialTokenSequence { '#' "line" IntegerLiteral '"' !["]* '"' endOfLine }
  
}
