@skip {
  whiteSpace
| comment { '/' (BlockComment | LineComment | NestingBlockComment) }
| SpecialTokenSequence
}

StringLiteral {
( WysiwygString
| AlternateWysiwygString
| DoubleQuotedString
| 'q' (DelimitedString | TokenString)
) StringPostfix?
}

@top Module { ModuleDeclaration (DeclDef | endOfLine)* | (DeclDef | endOfLine)+ }

DeclDef {
  AttributeSpecifier { Attribute ~attrStClass (':' | DeclarationBlock) }
| Declaration
| Constructor
| Destructor
| Postblit  { kwd<"this"> '(' kwd<"this"> ')' MemberFunctionAttribute* FunctionBody }
| Invariant { kwd<"invariant"> (BlockStatement | '(' (assertArguments ')' ';' | ')' BlockStatement)) }
| UnitTest  { kwd<"unittest"> BlockStatement }
| AliasThis { kwd<"alias"> Identifier kwd<"this"> ';' }
| StaticConstructor
| StaticDestructor
| SharedStaticConstructor
| SharedStaticDestructor
| DebugSpecification   { kwd<"debug">   '=' IntegerExpression ';' }
| VersionSpecification { kwd<"version"> '=' IntegerExpression ';' }
| TemplateDeclaration { kwd<"template"> Identifier templateParameters Constraint? AggregateBody }
| TemplateMixinDeclaration { kwd<"mixin"> kwd<"template"> Identifier templateParameters Constraint? AggregateBody }
| TemplateMixin
| MixinDeclaration { MixinExpression ';' }
| EmptyDeclaration { ';' }
}
@precedence { AttributeSpecifier, Declaration, MixinStatement, MixinDeclaration }

ModuleDeclaration { ModuleAttribute* ~module kwd<"module"> ModuleFullyQualifiedName ';' }
ModuleAttribute { DeprecatedAttribute | UserDefinedAttribute }
ModuleFullyQualifiedName { Identifier ( '.' Identifier )* }

ImportDeclaration { kwd<"public">? kwd<"static">? kwd<"import"> ImportList ';' }
ImportList { importBindings | import (',' ImportList)? }
import {( Identifier '=')? ModuleFullyQualifiedName }
importBindings { import ':' csv<importBind> }
importBind { Identifier ('=' Identifier )? }

Declaration {
  FuncDeclaration
| VarDeclarations ';'
| AliasDeclaration
| AggregateDeclaration
| EnumDeclaration
| ImportDeclaration
| ConditionalDeclaration
| StaticForeachDeclaration
| StaticAssert
}

AggregateDeclaration {
  ClassDeclaration
| InterfaceDeclaration
| StructDeclaration
| UnionDeclaration
}

VarDeclarations { StorageClass* BasicType Declarators | AutoDeclaration }

Declarators { DeclaratorInitializer (',' csv<DeclaratorIdentifier>)? }
DeclaratorInitializer { Declarator (templateParameters? '=' Initializer)? }
DeclaratorIdentifier  { Identifier (templateParameters? '=' Initializer)? }
Declarator { TypeSuffix* Identifier }

StorageClass {
  attributeAndStorageClass
| storageClassExclusive { kwd<"deprecated"> | kwd<"enum"> }
}
attributeAndStorageClass {
  LinkageAttribute | AlignAttribute | AtAttribute | TypeCtor | FunctionAttributeKwd
| kwd<"static"> | kwd<"abstract"> | kwd<"final"> | kwd<"override"> | kwd<"synchronized">
| kwd<"auto"> | kwd<"scope"> | kwd<"__gshared"> | kwd<"ref">
}

Initializer { kwd<"void"> | nonVoidInitializer }
nonVoidInitializer { AssignExpression | ArrayLiteral | StructInitializer }

AutoDeclaration { StorageClass+ ~attrStClass csv<autoAssignment> }
autoAssignment  { Identifier templateParameters? '=' Initializer }

AliasDeclaration {
  kwd<"alias"> (
    StorageClass* BasicType (Declarators | FuncDeclarator)
  | csv<aliasAssignment>
  ) ';'
}
aliasAssignment {
  Identifier templateParameters? '=' (
    StorageClass* (Type | BasicType Parameters MemberFunctionAttribute*)
  | FunctionLiteral
  )
}

Type { TypeCtor* BasicType TypeSuffix* }

TypeCtor { kwd<"const"> | kwd<"immutable"> | kwd<"inout"> | kwd<"shared"> }

BasicType {
  FundamentalType
| '.'? QualifiedIdentifier
| Typeof ('.' QualifiedIdentifier)?
| TypeCtor '(' Type ')'
| vector { kwd<"__vector"> '(' Type ')' }
| TraitsExpression
| MixinType { MixinExpression }
}

FundamentalType {
  kwd<"bool"> | kwd<"byte"> | kwd<"ubyte"> | kwd<"short"> | kwd<"ushort"> | kwd<"int"> | kwd<"uint">
| kwd<"long"> | kwd<"ulong"> | kwd<"cent"> | kwd<"ucent"> | kwd<"char"> | kwd<"wchar"> | kwd<"dchar">
| kwd<"float"> | kwd<"double"> | kwd<"real"> | kwd<"ifloat"> | kwd<"idouble"> | kwd<"ireal">
| kwd<"cfloat"> | kwd<"cdouble"> | kwd<"creal"> | kwd<"void">
}

TypeSuffix {
  '*'
| '[' (AssignExpression (".." AssignExpression)? | Type)? ']'
| kwd<"delegate"> Parameters MemberFunctionAttribute*
| kwd<"function"> Parameters FunctionAttribute*
}

QualifiedIdentifier { Identifier ('[' AssignExpression ']' | templateArguments)? ('.' QualifiedIdentifier)? }

Typeof { kwd<"typeof"> '(' (Expression | kwd<"return">) ')' }

Attribute {
  attributeAndStorageClass
| attributeExclusive { DeprecatedAttribute ~module | VisibilityAttribute | Pragma | kwd<"return"> }
}

FunctionAttributeKwd { kwd<"nothrow"> | kwd<"pure"> }

AtAttribute {
    '@' ("disable" | "nogc" | "live" | "property" | "safe" | "system" | "trusted")
    | UserDefinedAttribute ~module
}

DeclarationBlock { DeclDef | '{' DeclDef* '}' }

LinkageAttribute {
  kwd<"extern"> ('('(
    LinkageType
  | 'C' "++" ',' (QualifiedIdentifier | NamespaceList)?
  )')')?
}
LinkageType { 'C' "++"? | 'D' | "Windows" | "System" | "Objective" '-' 'C' }
NamespaceList { csvt<ConditionalExpression> }

AlignAttribute { kwd<"align"> ( '(' AssignExpression ')' )? }
DeprecatedAttribute { kwd<"deprecated"> ( '(' AssignExpression ')' )? }

VisibilityAttribute { kwd<"private"> | kwd<"package"> '(' QualifiedIdentifier ')' | kwd<"protected"> | kwd<"public"> | kwd<"export"> }

UserDefinedAttribute { '@' ('(' ArgumentList ')' | Identifier templateArguments? ('(' ArgumentList? ')')?) }

PragmaStatement   { Pragma (';' | noScopeStatement) }
Pragma { kwd<"pragma"> '(' Identifier (',' ArgumentList)? ')' }

Expression { CommaExpression }
CommaExpression  { csv<AssignExpression> }
AssignExpression { ConditionalExpression (assignmentToken AssignExpression)? }
ConditionalExpression { OrOrExpression ('?' Expression ':' ConditionalExpression)? }
OrOrExpression   { AndAndExpression ("||" OrOrExpression)? }
AndAndExpression { OrExpression ("&&" AndAndExpression)? }
OrExpression     { XorExpression ('|' OrExpression)? }
XorExpression    { AndExpression ('^' XorExpression)? }
AndExpression    { CmpExpression ('&' AndExpression)? }

CmpExpression {
  ShiftExpression (
    ( EqualExpression { ('!' | '=') '=' }
    | RelExpression   { ('<' | '>') '='? }
    | '!'? (IdentityExpression {kwd<"is">} | InExpression {kwd<"in">})
    )
    ShiftExpression
  )?
}
ShiftExpression { AddExpression (("<<" | ">>" '>'?) ShiftExpression)? }

AddExpression { MulExpression   (('+' | '-' | '~') AddExpression)? }
MulExpression { UnaryExpression (('*' | '/' | '%') MulExpression)? }

UnaryExpression {
  ThrowExpression
| PowExpression
| ('&' | '*' | '!' | '~' | '+' '+'? | '-' '-'? | kwd<"delete"> | kwd<"cast"> '(' (Type | TypeCtor+)? ')') UnaryExpression
}

NewExpression { kwd<"new"> Type ('[' AssignExpression ']' | '(' ArgumentList? ')')? | NewAnonClassExpression }

ArgumentList { csvt<AssignExpression> }

ThrowExpression { kwd<"throw"> AssignExpression ';' }
PowExpression { PostfixExpression ("^^" UnaryExpression)? }

PostfixExpression {
  PrimaryExpression
| PostfixExpression (
    '.' (Identifier templateArguments? | NewExpression)
  | "++" | "--"
  | '(' ArgumentList? ')'
  | '[' Slice? ']'
  )?
| TypeCtor* BasicType ~mixin '(' ArgumentList? ')'
}

Slice { csvt<AssignExpression (".." AssignExpression)?> }

PrimaryExpression {
  '.'? Identifier templateArguments?
| kwd<"this"> | kwd<"super"> | kwd<"null"> | kwd<"true"> | kwd<"false"> | '$'
| IntegerLiteral | FloatLiteral | CharacterLiteral
| StringLiteral+ | ArrayLiteral | AssocArrayLiteral | FunctionLiteral
| AssertExpression | MixinExpression ~mixin | ImportExpression | NewExpression
| FundamentalType '.' Identifier
| '(' Type ')' '.' (Identifier templateArguments?)
| FundamentalType '(' ArgumentList? ')'
| TypeCtor '(' Type ')' '.' (Identifier | '(' ArgumentList? ')')
| Typeof
| TypeidExpression | IsExpression
| '(' Expression ')'
| SpecialKeyword
| TraitsExpression
}

ArrayLiteral { '[' csvt<ArrayMemberInitialization>? ']' }
ArrayMemberInitialization { (AssignExpression ':')? nonVoidInitializer }

AssocArrayLiteral { '[' csv<KeyValuePair> ']' }
KeyValuePair { AssignExpression ':' AssignExpression }

FunctionLiteral {
  kwd<"function"> kwd<"ref">? Type? ParameterWithAttributes? FunctionLiteralBody2
| kwd<"delegate"> kwd<"ref">? Type? ParameterWithMemberAttributes? FunctionLiteralBody2
| kwd<"ref">? ParameterWithMemberAttributes FunctionLiteralBody2
| SpecifiedFunctionBody
| Identifier "=>" AssignExpression
}
ParameterWithAttributes { Parameters FunctionAttribute* }
ParameterWithMemberAttributes { Parameters MemberFunctionAttribute* }
FunctionLiteralBody2 { "=>" AssignExpression | SpecifiedFunctionBody }

AssertExpression { kwd<"assert"> '(' assertArguments ')' }
assertArguments { AssignExpression (',' AssignExpression)? ','? }

MixinExpression  { kwd<"mixin">  '(' ArgumentList ')' }

ImportExpression { kwd<"import"> '(' AssignExpression ')' }

TypeidExpression { kwd<"typeid"> '(' (Type | Expression) ')' }

IsExpression { kwd<"is"> '(' Type (Identifier? ((':' | "==") TypeSpecialization (',' csvt<templateParameter>)?)?) ')' }

TypeSpecialization {
  Type | TypeCtor
| kwd<"struct"> | kwd<"union">  | kwd<"class"> | kwd<"interface">
| kwd<"enum"> | kwd<"__vector"> | kwd<"function"> | kwd<"delegate">
| kwd<"super"> | kwd<"return">  | kwd<"__parameters">
| kwd<"module"> | kwd<"package">
}

SpecialKeyword {
  kwd<"__FILE__">
| kwd<"__FILE_FULL_PATH">
| kwd<"__MODULE__">
| kwd<"__LINE__">
| kwd<"__FUNCTION__">
| kwd<"__PRETTY_FUNCTION__">
}

statement { EmptyStatement | noScopeNonEmptyStatement }
EmptyStatement { ';' }
noScopeNonEmptyStatement { nonEmptyStatement | BlockStatement }
noScopeStatement { statement }
nonEmptyOrScopeBlockStatement { noScopeNonEmptyStatement }

nonEmptyStatement {
  nonEmptyStatementNoCaseNoDefault
| CaseStatement
| CaseRangeStatement
| DefaultStatement
}

nonEmptyStatementNoCaseNoDefault {
  LabeledStatement
| expressionStatement  { Expression ';' }
| declarationStatement { StorageClass* Declaration }
| IfStatement
| WhileStatement
| DoStatement
| ForStatement
| foreachStatement
| SwitchStatement
| finalSwitchStatement
| ContinueStatement { kwd<"continue"> Identifier? ';' }
| BreakStatement { kwd<"break"> Identifier? ';' }
| ReturnStatement { kwd<"return"> Expression? ';' }
| GotoStatement { kwd<"goto"> (Identifier | kwd<"default"> | kwd<"case"> Expression?) ';' }
| WithStatement { kwd<"with"> '(' (Expression | Symbol | Identifier templateArguments) ')' scopeStatement }
| SynchronizedStatement { kwd<"synchronized"> ('(' Expression ')')? scopeStatement }
| TryStatement
| ScopeGuardStatement
| AsmStatement { kwd<"asm"> FunctionAttribute* '{' (AsmInstruction ';')* '}' }
| MixinStatement { MixinExpression ';' }
| foreachRangeStatement
| PragmaStatement
| ConditionalStatement
| StaticForeachStatement
| StaticAssert
| TemplateMixin
| ImportDeclaration
}

scopeStatement { nonEmptyStatement | BlockStatement }

LabeledStatement { Identifier ':' statement? }

BlockStatement { '{' statement* '}' }

IfStatement { kwd<"if"> '(' ifCondition ')' ThenStatement { scopeStatement } (ElseStatement { scopeStatement })? }
ifCondition {
  ( ( (kwd<"auto"> | kwd<"scope"> | TypeCtor+) Identifier
    | TypeCtor* BasicType Declarator
    ) '='
  )? Expression
}

WhileStatement { kwd<"while"> '(' ifCondition ')' scopeStatement }

DoStatement { kwd<"do"> scopeStatement kwd<"while"> '(' Expression ')' ';' }

ForStatement { kwd<"for"> initialize Expression? ';' Expression? }
initialize { ';' | noScopeNonEmptyStatement }

aggregateForeach { Foreach '(' csv<foreachType> ';' Expression ')' }
foreachStatement { aggregateForeach noScopeNonEmptyStatement }

Foreach { kwd<"foreach"> | kwd<"foreach_reverse"> }

foreachType { ForeachTypeAttribute* (BasicType Declarator | kwd<"alias">? Identifier ) }
ForeachTypeAttribute { kwd<"enum"> | kwd<"ref"> | kwd<"scope"> | TypeCtor }

rangeForeach { Foreach '(' foreachType ';' Expression ".." Expression ')' }
foreachRangeStatement { rangeForeach scopeStatement }

SwitchStatement { kwd<"switch"> '(' Expression ')' scopeStatement }
CaseStatement { kwd<"case"> ArgumentList ':' statementNoCaseNoDefault* }
CaseRangeStatement { kwd<"case"> AssignExpression ':' ".." kwd<"case"> AssignExpression ':' statementNoCaseNoDefault* }
DefaultStatement { kwd<"default"> ':' statementNoCaseNoDefault* }
statementNoCaseNoDefault { EmptyStatement | nonEmptyStatementNoCaseNoDefault | BlockStatement }
finalSwitchStatement { kwd<"final"> SwitchStatement }

TryStatement { kwd<"try"> scopeStatement (catch+ FinallyStatement? | FinallyStatement) }
catch { kwd<"catch"> '(' BasicType Identifier? ')' noScopeNonEmptyStatement }
FinallyStatement { kwd<"finally"> noScopeNonEmptyStatement }

ScopeGuardStatement { kwd<"scope"> '(' (kwd<"exit"> | kwd<"success"> | kwd<"failure">) ')' nonEmptyOrScopeBlockStatement }

StructDeclaration {
  kwd<"struct"> (
      Identifier (';' | AggregateBody | templateParameters (';' | Constraint? AggregateBody))
    | AggregateBody
  )
}

UnionDeclaration {
  kwd<"union"> (
      Identifier (';' | AggregateBody | templateParameters (';' | Constraint? AggregateBody))
    | AggregateBody
  )
}

AggregateBody { '{' DeclDef* '}' }

StructInitializer { '{' csvt<StructMemberInitializer>? '}' }
StructMemberInitializer { (Identifier ':')? nonVoidInitializer }

ClassDeclaration {
  kwd<"class"> Identifier (
    ';'
    | BaseClassList? AggregateBody
    | templateParameters (';' | (Constraint? BaseClassList? | BaseClassList? Constraint?) AggregateBody)
  )
}

BaseClassList { ':' Interfaces }
Interfaces { csv<BasicType> }

Constructor { constBody | ConstructorTemplate }
Destructor  { '~' constBody }
StaticConstructor { kwd<"static"> constBody }
StaticDestructor  { kwd<"static"> Destructor }
SharedStaticConstructor { kwd<"shared"> StaticConstructor }
SharedStaticDestructor  { kwd<"shared"> StaticDestructor }
constBody { kwd<"this"> '(' ')' MemberFunctionAttribute* FunctionBody }

NewAnonClassExpression { kwd<"new"> kwd<"class"> ('(' ArgumentList? ')')? BasicType? Interfaces? AggregateBody }

InterfaceDeclaration {
  kwd<"interface"> Identifier (
      ';'
    | BaseClassList? AggregateBody
    | templateParameters (';' | (Constraint? BaseClassList? | BaseClassList Constraint) AggregateBody)
  )
}

EnumDeclaration {
  kwd<"enum"> (
      Identifier (':' Type)? (';' | '{' csvt<EnumMember> '}')
    | ':' Type '{' csvt<EnumMember> '}'
    | '{' csvt<AnonymousEnumMember> '}'
  )
}

EnumMember { enumMemberAttribute* Identifier ('=' AssignExpression)? }
enumMemberAttribute { DeprecatedAttribute | UserDefinedAttribute | "@disable" }

AnonymousEnumMember { EnumMember | Type Identifier '=' AssignExpression }

FuncDeclaration { StorageClass* BasicType FuncDeclarator FunctionBody | AutoFuncDeclaration }

AutoFuncDeclaration { StorageClass+ Identifier FuncDeclaratorSuffix FunctionBody }

FuncDeclarator { TypeSuffix* Identifier FuncDeclaratorSuffix }

FuncDeclaratorSuffix {
    Parameters MemberFunctionAttribute*
  | templateParameters Parameters MemberFunctionAttribute* Constraint?
}

Parameters { '(' parameterList? ')' }
parameterList { VariadicArgumentsAttribute* "..." | Parameter (',' parameterList?)? }

Parameter { parameterAttribute* (BasicType Declarator | Type) ("..." | '=' AssignExpression)? }
parameterAttribute { InOut | UserDefinedAttribute }

InOut {
    TypeCtor
  | kwd<"auto"> | kwd<"final"> | kwd<"in"> | kwd<"lazy">
  | kwd<"out">  | kwd<"ref"> | kwd<"return"> | kwd<"scope">
}

VariadicArgumentsAttribute { kwd<"const"> | kwd<"immutable"> | kwd<"return"> | kwd<"scope"> | kwd<"shared"> }

FunctionAttribute { FunctionAttributeKwd | AtAttribute }

MemberFunctionAttribute { VariadicArgumentsAttribute | FunctionAttribute | kwd<"inout"> }

FunctionBody { SpecifiedFunctionBody | MissingFunctionBody | ShortenedFunctionBody }

SpecifiedFunctionBody {
    (   kwd<"do">?
      | FunctionContract* (InOutContractExpression kwd<"do">? | InOutStatement kwd<"do">)
    ) BlockStatement
}

MissingFunctionBody { ';' | FunctionContract* (InOutContractExpression ';' | InOutStatement) }

ShortenedFunctionBody { InOutContractExpression* "=>" AssignExpression ';' }

FunctionContract { InOutContractExpression | InOutStatement }

InOutContractExpression { InContractExpression | OutContractExpression }

InOutStatement { InStatement | OutStatement }

InContractExpression  { kwd<"in"> '(' assertArguments ')' }
OutContractExpression { kwd<"out"> '(' Identifier? ';' assertArguments ')' }

InStatement  { kwd<"in"> BlockStatement }
OutStatement { kwd<"out"> ('(' Identifier ')')? BlockStatement }

templateParameters { '(' csvt<templateParameter>? ')' }

templateArguments { '!' (TemplateSingleArgument | '(' csvt<TemplateArgument>? ')') }

TemplateArgument { Type | AssignExpression | Symbol }

Symbol { '.'? symbolTail }
symbolTail { Identifier templateArguments? ('.' symbolTail)? }

TemplateSingleArgument {
  Identifier | FundamentalType | CharacterLiteral
| StringLiteral | IntegerLiteral | FloatLiteral
| kwd<"true"> | kwd<"false"> | kwd<"null"> | kwd<"this">
| SpecialKeyword
}

templateParameter {
  TemplateTypeParameter
| TemplateValueParameter
| TemplateAliasParameter
| TemplateSequenceParameter { Identifier "..." }
| TemplateThisParameter     { kwd<"this"> TemplateTypeParameter }
}

TemplateTypeParameter { Identifier (':' Type)? ('=' Type)? }
TemplateValueParameter {
  BasicType Declarator
  (':' ConditionalExpression)?
  ('=' (AssignExpression | SpecialKeyword))?
}
TemplateAliasParameter {
  kwd<"alias"> (Identifier | BasicType Declarator)
  (':' (Type | ConditionalExpression))?
  ('=' (Type | ConditionalExpression))?
}

ConstructorTemplate { kwd<"this"> templateParameters Parameters MemberFunctionAttribute* Constraint? (':' | FunctionBody) }

Constraint { kwd<"if"> '(' Expression ')' }

TemplateMixin { kwd<"mixin"> MixinTemplateName templateArguments? Identifier? ';' }

MixinTemplateName { Typeof? '.'? MixinQualifiedIdentifier }

MixinQualifiedIdentifier { Identifier (templateArguments? '.' MixinQualifiedIdentifier)? }

ConditionalDeclaration { condition (DeclarationBlock kwd<"else">)? (DeclarationBlock | ':' DeclDef*) }

ConditionalStatement { condition noScopeNonEmptyStatement (kwd<"else"> noScopeNonEmptyStatement)?}

condition { VersionCondition | DebugCondition | StaticIfCondition }

VersionCondition { kwd<"version"> '(' (IntegerExpression | kwd<"unittest"> | kwd<"assert">) ')' }

DebugCondition { kwd<"debug"> ('(' IntegerExpression ')')? }

StaticIfCondition { kwd<"static"> kwd<"if"> '(' AssignExpression ')' }

staticForeach { kwd<"static"> (aggregateForeach | rangeForeach) }

StaticForeachDeclaration { staticForeach (DeclarationBlock | ':' DeclDef*) }

StaticForeachStatement { staticForeach noScopeNonEmptyStatement }

StaticAssert { kwd<"static"> kwd<"assert"> '(' assertArguments ')' ';' }

TraitsExpression { kwd<"__traits"> '(' TraitsKeyword ',' csv<traitsArgument> ')' }
traitsArgument { AssignExpression | Type }

TraitsKeyword {
  "is" (
    "AbstractClass" | "Arithmetic" | "AssociativeArray" | "FinalClass" | "POD" | "Nested"
  | "Future" | "Deprecated" | "Floating" | "Integral" | "Scalar" | "StaticArray" | "Unsigned"
  | "Disabled" | "VirtualFunction" | "VirtualMethod" | "AbstractFunction" | "FinalFunction"
  | "StaticFunction" | "OverrideFunction" | "Template" | "Ref" | "Out" | "Lazy"
  | "ReturnOnStack" | "Copyable" | "ZeroInit" | "Module" | "Package" | "Same"
  )
| "has" ( "Member" | "CopyConstructor" | "Postblit" )
| "get" (
    "AliasThis" | "Attributes" | "FunctionAttributes" | "FunctionVariadicStyle"
  | "Linkage" | "Location" | "Member" | "Overloads" | "ParameterStorageClasses"
  | "PointerBitmap" | "CppNamespaces" | "Visibility" | "Protection" | "TargetInfo"
  | "VirtualFunctions" | "VirtualIndex" | "VirtualMethods" | "UnitTests"
  )
| "identifier" | "parent" | "child" | "classInstanceSize" | "allMembers" | "derivedMembers"
| "compiles" | "toType" | "initSymbol" | "parameters"
}

AsmInstruction {
    Identifier (':' AsmInstruction | operands)?
  | kwd<"align"> IntegerExpression
  | "even" | "naked"
  | 'd' ('b' | 's' | 'i' | 'l') (operands | StringLiteral)
  | 'd' ('d' | 'e' | 'f') operands
  | 'd' ('q' | 'w')  StringLiteral
  | (kwd<"int"> | kwd<"in"> | kwd<"out">) operands?
}
operands { csv<AsmExp> }

IntegerExpression { IntegerLiteral | Identifier }

AsmExp { AsmLogOrExp ('?' AsmExp ':' AsmExp)? }
AsmLogOrExp { AsmLogAndExp ("||" AsmLogOrExp)? }
AsmLogAndExp { AsmOrExp ("&&" AsmLogAndExp)? }
AsmOrExp    { AsmXorExp ('|' AsmOrExp)? }
AsmXorExp   { AsmAndExp ('^' AsmXorExp)? }
AsmAndExp   { AsmEqualExp ('&' AsmAndExp)? }
AsmEqualExp { AsmRelExp (('=' | '!') '=' AsmEqualExp)? }
AsmRelExp   { AsmShiftExp (('<' | '>') '=' AsmRelExp)? }
AsmShiftExp { AsmAddExp (("<<" | ">>" '>'?) AsmShiftExp)? }
AsmAddExp   { AsmMulExp (('+' | '-') AsmAddExp)? }
AsmMulExp   { AsmBrExp (('*' | '/' | '%') AsmMulExp)? }
AsmBrExp    { AsmUnaExp ('[' AsmExp ']')? }

AsmUnaExp {
  (AsmTypePrefix | "offsetof" | "seg") AsmExp
| ('+' | '!' | '~' | '-') AsmUnaExp
| AsmPrimaryExp
}

AsmPrimaryExp {
  IntegerLiteral | FloatLiteral
| Register (':' AsmExp)?
| Register64 (':' AsmExp)?
| dotIdentifier
| kwd<"this"> | "__LOCAL_SIZE" | '$'
}
dotIdentifier { FundamentalType '.' Identifier | Identifier ('.' dotIdentifier)? }

AsmTypePrefix { ("near" | "far" | ('d' | 'q') "word" | FundamentalType) "ptr" }


kwd<word>  { @specialize[@name={word}]<Identifier, word> }

csv<term>  { term (',' term)* }

csvt<term> { csv<term> ','? }


@external tokens nestingComment from "./tokens" { NestingBlockComment }

@external tokens delimString from "./tokens" { DelimitedString }

@external tokens tokString from "./tokens" { TokenString }


@tokens {
  character { $[\u{20}-\u{10FFFF}] }

  endOfFile { $[\u0000\u001A] }
  
  endOfLine { "\r" | "\n" | "/r/n" | "\u2028" | "\u2029" | endOfFile? }
  
  whiteSpace { space+ }
  space { $[ \t\v\f] }
  
  BlockComment { "*" ![*/]* "*/" }
  LineComment { "/" (!endOfLine)* }
  
  Identifier {
    ($[a-zA-Z_] | universalAlpha) ($[a-zA-Z0-9_] | universalAlpha)*
  }
  universalAlpha {
    latin | greek | cyrillic | armenian | hebrew | arabic | devanagari | bengali | gurmukhi
  | gujarati | oriya | tamil | telugu | kannada | malayalam | thai | lao | tibetan | georgian
  | hiragana | katakana | bopomofo | cjk | hangul | other
  }
  latin { $[ªºµ·À-ÖØ-öø-ʯʰ-ʸʻ-ˁːˑˠ-ˤḀ-ỿⁿ] }
  greek { $[ͺΆΈ-ΊΌΎ-ΡΣ-ϳἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ] }
  cyrillic { $[Ѐ-ҁҊ-ӿ] }
  armenian { $[Ա-Ֆա-և] }
  hebrew { $[\u05B0−\u05F2] }
  arabic { $[\u0620-\u0652\u0660-\u0669\u0670-\u06DC\u06E5-\u06E8\u06EA-\u06F9] }
  devanagari { $[\u0900-\u0939ऽ-\u0963०-९] }
  bengali { $[ঀ-\u0983অ-ঌএঐও-নপরলশ-হ\u09BE-\u09C4\u09C7\u09C8\u09CB-ৎড়ঢ়য়-\u09E3০-৯] }
  gurmukhi { $[\u0A02ਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4Dਖ਼-ੜਫ਼੦-੯ੴ] }
  gujarati { $[\u0A81-\u0A83અ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACDૐૠૡ૦-૯ૹ] }
  oriya { $[\u0B01-ଃଅ-ଌଏଐଓ-ନପ-ରଲହଽ\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4Dଡ଼ଢ଼ୟ-ୡ୦-୯ୱ] }
  tamil { $[\u0B82\u0B83அ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-\u0BC2ெ-ை\u0BCA-\u0BCD௦-௯] }
  telugu { $[ఁ-ఌఎ-ఐఒ-నప-హఽ-\u0C44\u0C46-\u0C48\u0C4A-\u0C4Dౠౡ౦-౯] }
  kannada { $[ಀ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCDೞೠೡ೦-೯] }
  malayalam { $[\u0D02-ഌഎ-ഐഒ-ഺഽ-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D൘-ൡ൦-ൿ] }
  thai { $[ก-\u0E3Aเ-๛] }
  lao { $[ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອຮ\u0EB0-\u0EB9\u0EBB-ຽເ-ໄໆ\u0EC8-\u0ECD໐-໙ໜ-ໟ] }
  tibetan { $[ༀ\u0F18\u0F19༠-༳\u0F35\u0F37\u0F39\u0F3E-ཇཉ-ཬ\u0F71-ྌ\u0F90-\u0F97\u0F99-\u0FBC] }
  georgian { $[Ⴀ-ჅჇჍა-ჺჼ-ჿ] }
  hiragana { $[ぁ-ゖ゛゜ゟ] }
  katakana { $[ァ-ーヿ] }
  bopomofo { $[ㄅ-ㄭ] }
  cjk { $[々-〇〡-〩\u4E00—\u9FFF] }
  hangul { $[\uAC00—\uD7AF] }
  other { $[‿⁀ℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℱℳ-ℸⅠ-ↂ] }
  
  WysiwygString { 'r' '"' !["]* '"' }

  AlternateWysiwygString { '`' ![`]* '`' }

  DoubleQuotedString { '"' (EscapeSequence | !["])* '"' }

  EscapeSequence {
    '\\' 
  ( $['"?\\0abfnrtv]
  | 'x' HexDigit HexDigit
  | OctalDigit OctalDigit? OctalDigit?
  | 'u' HexDigit HexDigit HexDigit HexDigit
  | 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
  | NamedCharacterEntity )
  }
  StringPostfix { $[cwd] }
  
  assignmentToken { ($[+*/%&|^~-] | "<<" | ">>" | ">>>" | "^^")? '=' }
  
  CharacterLiteral { "'" (character | EscapeSequence)? "'" }
  
  IntegerLiteral { integer integerSuffix? }
  integerSuffix { 'L' $[uU]? | $[uU] 'L'? }
  
  integer { decimalInteger | binaryInteger | hexadecimalInteger | octalInteger }
  
  decimalInteger { '0' | $[1-9] $[0-9_]* }
  binaryInteger  { '0' $[bB] "_"* $[01] $[01_]* }
  hexadecimalInteger { '0' $[xX] '_'* HexDigit (HexDigit | '_')* }
  octalInteger { '0' $[0_]* OctalDigit '_'* }
  
  decimalDigitsNoSingleUS { decimalDigitsNoStartingUS | '_' $[0-9_]* }
  decimalDigitsNoStartingUS { $[0-9] $[0-9_]* }
  OctalDigit { $[0-7] }
  hexDigitsNoSingleUS { hexDigitsNoStartingUS | '_' (HexDigit | '_')* }
  hexDigitsNoStartingUS { HexDigit (HexDigit | '_')* }
  HexDigit   { $[0-9a-fA-F] }
  
  FloatLiteral {
    float $[fFL]? 'i'?
  | integer ( $[fF] 'i'? | 'L'? 'i' )
  }
  
  float { decimalFloat | hexFloat }
  
  decimalFloat {
    decimalDigitsNoStartingUS '.' decimalDigitsNoStartingUS?
  | decimalDigitsNoStartingUS? '.' decimalDigitsNoStartingUS decimalExponent
  | decimalDigitsNoStartingUS decimalExponent
  }
  decimalExponent { $[eE] $[+-]? decimalDigitsNoSingleUS }
  hexFloat {
    '0' $[xX] (
      hexDigitsNoSingleUS? '.' hexDigitsNoStartingUS hexExponent
    | hexDigitsNoSingleUS hexExponent
    )
  }
  hexExponent { $[pP] $[+-]? decimalDigitsNoSingleUS }
  
  SpecialTokenSequence { '#' "line" IntegerLiteral '"' !["]* '"' endOfLine }

  Register {
    'A' $[LHX]
  | 'B' $[LHXP]
  | 'C' ($[LHXS]  | 'R' $[0234])
  | 'D' ($[LHXIS] | 'R' $[0-367])
  | 'E' ($[AC] 'X' | 'B' $[XP] | 'D' $[XI] | 'S' $[PI]?)
  | "FS" | "GS"
  | 'S' ($[PIS] | 'T' ('(' $[0-7] ')')?)
  | "TR" $[3-7]
  | 'X'? "MM" $[0-7]
  }

  Register64 {
    'R' ($[AC] 'X' | 'B' $[XP] | 'D' $[XI] | 'S' $[PI] | ($[89] | '1' $[0-5]) $[BWD])
  | "BPL" | "DIL" | 'S' ("PL" | "IL") 
  | "XMM" ($[89]   | '1' $[0-5])
  | "YMM" ($[02-9] | '1' $[0-5]?)
  }

  NamedCharacterEntity { '&' Identifier ';' }
  
}
